/**
 * ============================================[ ğŸ“¢YOUTUBE DOWNLOADER CORE <( YT-CORE )/>ğŸ“¹ ]====================================
 * ğŸš€ Unlock effortless audio/video downloads with YT-COREâ€”a command-line, Node.js, and streaming powerhouse.
 * ğŸµ Meticulously designed for enthusiasts, YT-CORE stands out as a feature-rich package, evolving with state-of-the-art
 * ğŸ”¥ functionalities from Youtube-DL and Python yt-core.
 * ğŸš€ Elevate your media experience!
 * ğŸŒˆ Dive into the world of limitless possibilities.
 * ============================================[ ğŸš¨License: MIT] [ ğŸ§™ğŸ»Owner: ShovitDutta]====================================
 * MIT License
 * Original Library
 * - Copyright (c) Shovit Dutta <shovitdutta1@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * ============================================[ ğŸš¨License: MIT] [ ğŸ§™ğŸ»Owner: ShovitDutta]====================================
 */
import colors from 'colors';
import axios from 'axios';
import * as z from 'zod';
import Spinnies from 'spinnies';
import { randomUUID } from 'crypto';
import YouTubeID from '@shovit/ytid';
import search$1 from 'yt-search';
import * as fs from 'fs';
import * as path from 'path';
import fluentffmpeg from 'fluent-ffmpeg';
import { Readable, Writable } from 'stream';
import readline from 'readline';
import async from 'async';

function help() {
    return Promise.resolve(colors.bold.white(`
âœ•â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€âœ•
â”ƒ                                     YOUTUBE DOWNLOADER CORE <( YT-CORE /)>                                    â”ƒ
â”ƒ                                            (License: MIT)                                                   â”ƒ
â”ƒ                                         [Owner: ShovitDutta]                                                â”ƒ
â”ƒ                                       { Web: rebrand.ly/mixly }                                             â”ƒ
â”ƒ                                                                                                             â”ƒ
â”ƒ                               Supports both async/await and promise.then()                                  â”ƒ
â”ƒ                   Full support for CommonJS (CJS), ECMAScript (ESM), and TypeScript (TS)                    â”ƒ
â”ƒâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ƒ
â”ƒ INSTALLATION  â”ƒ â LOCALLY: â                                                                                â”ƒ
â”ƒ               â”ƒ   bun add yt-core                                                                           â”ƒ
â”ƒ               â”ƒ   yarn add yt-core                                                                          â”ƒ
â”ƒ               â”ƒ   npm install yt-core                                                                       â”ƒ
â”ƒ               â”ƒ   pnpm install yt-core                                                                      â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ â GLOBALLY: â                                                                               â”ƒ
â”ƒ               â”ƒ   yarn global add yt-core                                                   (use cli)       â”ƒ
â”ƒ               â”ƒ   npm install --global yt-core                                              (use cli)       â”ƒ
â”ƒ               â”ƒ   pnpm install --global yt-core                                             (use cli)       â”ƒ
â”ƒ               â”ƒâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ƒ
â”ƒ    FILTERS    â”ƒ â AUDIO ONLY: â                                                                             â”ƒ
â”ƒ               â”ƒ   bassboost                  echo                                                           â”ƒ
â”ƒ               â”ƒ   flanger                    nightcore                                                      â”ƒ
â”ƒ               â”ƒ   panning                    phaser                                                         â”ƒ
â”ƒ               â”ƒ   reverse                    slow                                                           â”ƒ
â”ƒ               â”ƒ   speed                      subboost                                                       â”ƒ
â”ƒ               â”ƒ   superslow                  superspeed                                                     â”ƒ
â”ƒ               â”ƒ   surround                   vaporwave                                                      â”ƒ
â”ƒ               â”ƒ   vibrato                                                                                   â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ â VIDEO ONLY: â                                                                             â”ƒ
â”ƒ               â”ƒ   grayscale                                                                                 â”ƒ
â”ƒ               â”ƒ   invert                                                                                    â”ƒ
â”ƒ               â”ƒ   rotate90                                                                                  â”ƒ
â”ƒ               â”ƒ   rotate180                                                                                 â”ƒ
â”ƒ               â”ƒ   rotate270                                                                                 â”ƒ
â”ƒ               â”ƒ   flipHorizontal                                                                            â”ƒ
â”ƒ               â”ƒ   flipVertical                                                                              â”ƒ
â”ƒ               â”ƒâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ƒ
â”ƒ   CLI USAGE   â”ƒ â INFO GRABBERS: â                                                                          â”ƒ
â”ƒ               â”ƒ   yt-core version                                                             (alias: v)    â”ƒ
â”ƒ               â”ƒ   yt-core help                                                                (alias: h)    â”ƒ
â”ƒ               â”ƒ   yt-core extract --query="video/url"                                         (alias: e)    â”ƒ
â”ƒ               â”ƒ   yt-core search-yt --query="video/url"                                       (alias: s)    â”ƒ
â”ƒ               â”ƒ   yt-core list-formats --query="video/url"                                    (alias: f)    â”ƒ 
â”ƒ               â”ƒ   yt-core get-video-data --query="video/url"                                  (alias: gvd)  â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ â AUDIO ONLY: â                                                                             â”ƒ
â”ƒ               â”ƒ   yt-core audio-lowest --query="video/url"                                    (alias: al)   â”ƒ
â”ƒ               â”ƒ   yt-core audio-highest --query="video/url"                                   (alias: ah)   â”ƒ
â”ƒ               â”ƒ   yt-core audio-quality-custom --query="video/url" --format="valid-format"    (alias: aqc)  â”ƒ
â”ƒ               â”ƒ       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                        â”ƒ
â”ƒ               â”ƒ   yt-core audio-lowest --query="video/url" --filter="valid-filter"            (filter)      â”ƒ
â”ƒ               â”ƒ   yt-core audio-highest --query="video/url" --filter="valid-filter"           (filter)      â”ƒ
â”ƒ               â”ƒ   yt-core audio-quality-custom --query="video/url" --format="valid-format"    ........      â”ƒ
â”ƒ               â”ƒ                                                   --filter="valid-filter"    (filter)       â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ â VIDEO ONLY: â                                                                             â”ƒ
â”ƒ               â”ƒ   yt-core video-lowest --query="video/url"                                    (alias: vl)   â”ƒ
â”ƒ               â”ƒ   yt-core video-highest --query="video/url"                                   (alias: vh)   â”ƒ
â”ƒ               â”ƒ   yt-core video-quality-custom --query="video/url" --format="valid-format"    (alias: vqc)  â”ƒ
â”ƒ               â”ƒ       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                        â”ƒ
â”ƒ               â”ƒ   yt-core video-lowest --query="video/url" --filter="valid-filter"            (filter)      â”ƒ
â”ƒ               â”ƒ   yt-core video-highest --query="video/url" --filter="valid-filter"           (filter)      â”ƒ
â”ƒ               â”ƒ   yt-core video-quality-custom --query="video/url" --format="valid-format"    ........      â”ƒ
â”ƒ               â”ƒ                                                   --filter="valid-filter"    (filter)       â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ â AUDIO + VIDEO MIX: â                                                                      â”ƒ
â”ƒ               â”ƒ   yt-core audio-video-lowest --query="video/url"                              (alias: avl)  â”ƒ
â”ƒ               â”ƒ   yt-core audio-video-highest --query="video/url"                             (alias: avh)  â”ƒ
â”ƒ               â”ƒâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ƒ
â”ƒ   IMPORTING   â”ƒ   import ytdlp from "yt-core";                                            TypeScript (ts)   â”ƒ
â”ƒ               â”ƒ   import ytdlp from "yt-core";                                            ECMAScript (esm)  â”ƒ
â”ƒ               â”ƒ   const ytdlp = require("yt-core");                                       CommonJS   (cjs)  â”ƒ
â”ƒ               â”ƒâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ƒ
â”ƒ INFO GRABBERS â”ƒ   ytdlp.info.help();                                                                        â”ƒ
â”ƒ               â”ƒ   ytdlp.info.search({ query: "" });                                                         â”ƒ
â”ƒ               â”ƒ   ytdlp.info.extract({ query: "" });                                                        â”ƒ
â”ƒ               â”ƒ   ytdlp.info.list_formats({ query: "" });                                                   â”ƒ
â”ƒ               â”ƒ   ytdlp.info.get_video_data({ query: "" });                                                 â”ƒ
â”ƒ               â”ƒ   ytdlp.extract_playlist_videos({ playlistUrls: ["", "", "", ""] });                        â”ƒ
â”ƒ               â”ƒâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ƒ
â”ƒ  DOWNLOADERS  â”ƒ â AUDIO ONLY: â                                                                             â”ƒ
â”ƒ               â”ƒ   ytdlp.audio.download.lowest({ query: "", filter: "" });                                   â”ƒ
â”ƒ               â”ƒ   ytdlp.audio.download.highest({ query: "", filter: "" });                                  â”ƒ
â”ƒ               â”ƒ   ytdlp.audio.download.custom({ query: "", format: "", filter: "" });                       â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ â VIDEO ONLY: â                                                                             â”ƒ
â”ƒ               â”ƒ   ytdlp.video.download.lowest({ query: "", filter: "" });                                   â”ƒ
â”ƒ               â”ƒ   ytdlp.video.download.highest({ query: "", filter: "" });                                  â”ƒ
â”ƒ               â”ƒ   ytdlp.video.download.custom({ query: "", filter: "" });                                   â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ â AUDIO + VIDEO MIX: â                                                                      â”ƒ
â”ƒ               â”ƒ   ytdlp.audio_video.download.lowest({ query: "" });                                         â”ƒ
â”ƒ               â”ƒ   ytdlp.audio_video.download.highest({ query: "" });                                        â”ƒ
â”ƒ               â”ƒâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ƒ
â”ƒ  MEDIA PIPE   â”ƒ â AUDIO ONLY: â                                                                             â”ƒ
â”ƒ               â”ƒ   ytdlp.audio.pipe.lowest({ query: "", filter: "" });                                       â”ƒ
â”ƒ               â”ƒ   ytdlp.audio.pipe.highest({ query: "", filter: "" });                                      â”ƒ
â”ƒ               â”ƒ   ytdlp.audio.pipe.custom({ query: "", format: "", filter: "" });                           â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ â VIDEO ONLY: â                                                                             â”ƒ
â”ƒ               â”ƒ   ytdlp.video.pipe.lowest({ query: "", filter: "" });                                       â”ƒ
â”ƒ               â”ƒ   ytdlp.video.pipe.highest({ query: "", filter: "" });                                      â”ƒ
â”ƒ               â”ƒ   ytdlp.video.pipe.custom({ query: "", filter: "" });                                       â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ                                                                                             â”ƒ
â”ƒ               â”ƒ â AUDIO + VIDEO MIX: â                                                                      â”ƒ
â”ƒ               â”ƒ   ytdlp.audio_video.pipe.lowest({ query: "" });                                             â”ƒ
â”ƒ               â”ƒ   ytdlp.audio_video.pipe.highest({ query: "" });                                            â”ƒ
â”ƒâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”ƒ
â”ƒ                                     YOUTUBE DOWNLOADER CORE <( YT-CORE /)>                                    â”ƒ
â”ƒ                                            (License: MIT)                                                   â”ƒ
â”ƒ                                         [Owner: ShovitDutta]                                                â”ƒ
â”ƒ                                       { Web: rebrand.ly/mixly }                                             â”ƒ
â”ƒ                                                                                                             â”ƒ
â”ƒ                               Supports both async/await and promise.then()                                  â”ƒ
â”ƒ                   Full support for CommonJS (CJS), ECMAScript (ESM), and TypeScript (TS)                    â”ƒ
âœ•â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€âœ•`));
}

async function scrape(query) {
    try {
        const host = "https://creepy-fly-kimono.cyclic.app/scrape";
        const response = await axios.get(host + "?query=" + encodeURIComponent(query));
        return {
            stdout: response.data.stdout || null,
            stderr: response.data.stderr || null,
            status: response.data.status || null,
        };
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return {
                    stderr: error.message,
                    stdout: null,
                    status: 500,
                };
            default:
                return {
                    stderr: "Internal server error",
                    stdout: null,
                    status: 500,
                };
        }
    }
}

async function search({ query }) {
    try {
        switch (true) {
            case !query || typeof query !== "string":
                return {
                    message: "Invalid query parameter",
                    status: 500,
                };
            default:
                return (await scrape(query)).stdout;
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return {
                    message: error.message,
                    status: 500,
                };
            default:
                return {
                    message: "Internal server error",
                    status: 500,
                };
        }
    }
}

async function ytCore$1(query) {
    const host = "https://creepy-fly-kimono.cyclic.app/";
    try {
        const response = await axios.get(host + "?query=" + encodeURIComponent(query));
        if (response.data.status === 200)
            return response.data.stdout;
        else
            return null;
    }
    catch (error) {
        return null;
    }
}

var version = "3.0.8";

const spinnies = new Spinnies();
async function Engine({ query, }) {
    let videoId, TubeCore, TubeBody;
    const metaSpin = randomUUID();
    spinnies.add(metaSpin, {
        text: new Date().toLocaleString() +
            " " +
            colors.bold.blue("INFO: ") +
            colors.reset(""),
    });
    spinnies.update(metaSpin, {
        text: new Date().toLocaleString() +
            " " +
            colors.bold.blue("INFO: ") +
            "â­• using yt-core version <(" +
            version +
            ")>" +
            colors.reset(""),
    });
    if (!query || query.trim() === "") {
        spinnies.fail(metaSpin, {
            text: new Date().toLocaleString() +
                " " +
                colors.bold.red("ERROR: ") +
                "âŒ 'query' is required..." +
                colors.reset(""),
        });
        return;
    }
    if (/https/i.test(query) && /list/i.test(query)) {
        spinnies.fail(metaSpin, {
            text: new Date().toLocaleString() +
                " " +
                colors.bold.red("ERROR: ") +
                "âŒ use extract_playlist_videos() for playlists..." +
                colors.reset(""),
        });
        return;
    }
    if (/https/i.test(query) && !/list/i.test(query)) {
        spinnies.update(metaSpin, {
            text: new Date().toLocaleString() +
                " " +
                colors.bold.blue("INFO: ") +
                "â­• fetching metadata for: <(" +
                query +
                ")>" +
                colors.reset(""),
        });
        videoId = await YouTubeID(query);
    }
    else {
        function isYouTubeID(input) {
            const regex = /^[a-zA-Z0-9_-]{11}$/;
            const match = input.match(regex);
            if (match)
                return match[0];
            else
                return null;
        }
        videoId = isYouTubeID(query);
    }
    if (videoId) {
        TubeBody = await scrape(videoId);
        if (!TubeBody.stdout.Link) {
            spinnies.fail(metaSpin, {
                text: new Date().toLocaleString() +
                    " " +
                    colors.bold.red("ERROR: ") +
                    "âŒ no data returned from server..." +
                    colors.reset(""),
            });
            return;
        }
        else {
            spinnies.update(metaSpin, {
                text: new Date().toLocaleString() +
                    " " +
                    colors.bold.blue("INFO: ") +
                    "ğŸ“¡ preparing payload for <(" +
                    TubeBody.stdout.Title +
                    "Author:" +
                    TubeBody.stdout.Uploader +
                    ")>" +
                    colors.reset(""),
            });
            TubeCore = await ytCore$1(TubeBody.stdout.Link);
        }
    }
    else {
        TubeBody = await scrape(query);
        if (!TubeBody.stdout.Link) {
            spinnies.fail(metaSpin, {
                text: new Date().toLocaleString() +
                    " " +
                    colors.bold.red("ERROR: ") +
                    "âŒ no data returned from server..." +
                    colors.reset(""),
            });
            return;
        }
        else {
            spinnies.update(metaSpin, {
                text: new Date().toLocaleString() +
                    " " +
                    colors.bold.blue("INFO: ") +
                    "ğŸ“¡ preparing payload for <(" +
                    TubeBody.stdout.Title +
                    "Author:" +
                    TubeBody.stdout.Uploader +
                    ")>" +
                    colors.reset(""),
            });
            TubeCore = await ytCore$1(TubeBody.stdout.Link);
        }
    }
    if (TubeCore === null) {
        spinnies.fail(metaSpin, {
            text: new Date().toLocaleString() +
                " " +
                colors.bold.red("ERROR: ") +
                "âŒ please try again later..." +
                colors.reset(""),
        });
        return;
    }
    spinnies.succeed(metaSpin, {
        text: new Date().toLocaleString() +
            " " +
            colors.bold.blue("INFO: ") +
            "â£ï¸ Thank you for using yt-core! If you enjoy the project, consider Staring the GitHub repo https://github.com/shovitdutta/mixly/yt-core." +
            colors.reset(""),
    });
    return Promise.resolve(JSON.parse(TubeCore));
}

function extract({ query }) {
    return new Promise(async (resolve, reject) => {
        try {
            const zval = z
                .object({
                query: z.string(),
            })
                .parse({ query });
            const EnResp = await Engine(zval);
            if (!EnResp)
                return reject("Unable to get response from YouTube...");
            const uploadDate = EnResp.metaTube.upload_date;
            const uploadDateFormatted = new Date(uploadDate.replace(/(\d{4})(\d{2})(\d{2})/, "$1-$2-$3"));
            const currentDate = new Date();
            const daysAgo = Math.floor((currentDate.getTime() - uploadDateFormatted.getTime()) /
                (1000 * 60 * 60 * 24));
            const prettyDate = new Date(uploadDate.replace(/(\d{4})(\d{2})(\d{2})/, "$1-$2-$3")).toLocaleDateString("en-US", {
                year: "numeric",
                month: "long",
                day: "numeric",
            });
            const uploadAgoObject = calculateUploadAgo(daysAgo);
            const videoTimeInSeconds = EnResp.metaTube.duration;
            const videoDuration = calculateVideoDuration(videoTimeInSeconds);
            const viewCountFormatted = formatCount(EnResp.metaTube.view_count);
            const likeCountFormatted = formatCount(EnResp.metaTube.like_count);
            function calculateUploadAgo(days) {
                const years = Math.floor(days / 365);
                const months = Math.floor((days % 365) / 30);
                const remainingDays = days % 30;
                const formattedString = `${years > 0 ? years + " years, " : ""}${months > 0 ? months + " months, " : ""}${remainingDays} days`;
                return {
                    years,
                    months,
                    days: remainingDays,
                    formatted: formattedString,
                };
            }
            function calculateVideoDuration(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = seconds % 60;
                const formattedString = `${hours > 0 ? hours + " hours, " : ""}${minutes > 0 ? minutes + " minutes, " : ""}${remainingSeconds} seconds`;
                return {
                    hours,
                    minutes,
                    seconds: remainingSeconds,
                    formatted: formattedString,
                };
            }
            function formatCount(count) {
                const abbreviations = ["K", "M", "B", "T"];
                for (let i = abbreviations.length - 1; i >= 0; i--) {
                    const size = Math.pow(10, (i + 1) * 3);
                    if (size <= count) {
                        const formattedCount = Math.round((count / size) * 10) / 10;
                        return `${formattedCount}${abbreviations[i]}`;
                    }
                }
                return `${count}`;
            }
            const payload = {
                audio_data: EnResp.AudioTube,
                video_data: EnResp.VideoTube,
                hdrvideo_data: EnResp.HDRVideoTube,
                meta_data: {
                    id: EnResp.metaTube.id,
                    original_url: EnResp.metaTube.original_url,
                    webpage_url: EnResp.metaTube.webpage_url,
                    title: EnResp.metaTube.title,
                    view_count: EnResp.metaTube.view_count,
                    like_count: EnResp.metaTube.like_count,
                    view_count_formatted: viewCountFormatted,
                    like_count_formatted: likeCountFormatted,
                    full_title: EnResp.metaTube.Fulltitle,
                    uploader: EnResp.metaTube.uploader,
                    uploader_id: EnResp.metaTube.uploader_id,
                    uploader_url: EnResp.metaTube.uploader_url,
                    thumbnail: EnResp.metaTube.thumbnail,
                    categories: EnResp.metaTube.categories,
                    time: videoTimeInSeconds,
                    duration: videoDuration,
                    age_limit: EnResp.metaTube.age_limit,
                    live_status: EnResp.metaTube.live_status,
                    description: EnResp.metaTube.description,
                    full_description: EnResp.metaTube.description,
                    upload_date: prettyDate,
                    upload_ago: daysAgo,
                    upload_ago_formatted: uploadAgoObject,
                    comment_count: EnResp.metaTube.comment_count,
                    comment_count_formatted: formatCount(EnResp.metaTube.comment_count),
                    channel_id: EnResp.metaTube.channel_id,
                    channel_name: EnResp.metaTube.channel,
                    channel_url: EnResp.metaTube.channel_url,
                    channel_follower_count: EnResp.metaTube.channel_follower_count,
                    channel_follower_count_formatted: formatCount(EnResp.metaTube.channel_follower_count),
                },
            };
            resolve(payload);
        }
        catch (error) {
            reject(error instanceof z.ZodError ? error.errors : error);
        }
    });
}

async function get_playlist({ playlistUrls, }) {
    try {
        const proTubeArr = [];
        const preTube = new Set();
        for (const url of playlistUrls) {
            const ispUrl = url.match(/list=([a-zA-Z0-9_-]+)/);
            if (!ispUrl) {
                console.error(colors.bold.red("ERROR: "), "Invalid YouTube Playlist URL:", url);
                continue;
            }
            const resp = await search$1({ listId: ispUrl[1] });
            if (!resp) {
                console.error(colors.bold.red("ERROR: "), "Invalid Data Found For:", ispUrl[1]);
                continue;
            }
            for (let i = 0; i < resp.videos.length; i++) {
                try {
                    const videoId = resp.videos[i].videoId;
                    const metaTube = await search$1({ videoId: videoId });
                    console.log(colors.bold.green("INFO:"), colors.bold.green("<("), metaTube.title, colors.bold.green("by"), metaTube.author.name, colors.bold.green(")>"));
                    if (preTube.has(metaTube.videoId))
                        continue;
                    else {
                        const { author: { name: authorName, url: authorUrl }, duration, seconds, genre, ...newTube } = metaTube;
                        proTubeArr.push({ ...newTube, authorName, authorUrl });
                    }
                }
                catch (error) {
                    console.error(colors.bold.red("ERROR: "), error);
                }
            }
        }
        return proTubeArr;
    }
    catch (error) {
        return error instanceof z.ZodError ? error.errors : error;
    }
}

function list_formats({ query, }) {
    return new Promise(async (resolve, reject) => {
        try {
            const zval = z
                .object({
                query: z.string(),
            })
                .parse({ query });
            const EnResp = await Engine(zval);
            if (!EnResp)
                return reject("Unable to get response from YouTube...");
            const fprem = (data) => data.filter((out) => !out.meta_dl.originalformat.includes("Premium"));
            const EnBody = {
                AudioFormatsData: fprem(EnResp.AudioTube).map((out) => [
                    out.meta_dl.originalformat,
                    out.meta_info.filesizebytes,
                    out.meta_info.filesizeformatted,
                ]),
                VideoFormatsData: fprem(EnResp.VideoTube).map((out) => [
                    out.meta_dl.originalformat,
                    out.meta_info.filesizebytes,
                    out.meta_info.filesizeformatted,
                ]),
                HdrVideoFormatsData: fprem(EnResp.HDRVideoTube).map((out) => [
                    out.meta_dl.originalformat,
                    out.meta_info.filesizebytes,
                    out.meta_info.filesizeformatted,
                ]),
            };
            resolve(EnBody);
        }
        catch (error) {
            reject(error instanceof z.ZodError ? error.errors : error);
        }
    });
}

function get_video_data({ query, }) {
    return new Promise(async (resolve, reject) => {
        try {
            const zval = z
                .object({
                query: z.string(),
            })
                .parse({ query });
            const EnResp = await Engine(zval);
            if (!EnResp)
                return reject("Unable to get response from YouTube...");
            const uploadDate = EnResp.metaTube.upload_date;
            const uploadDateFormatted = new Date(uploadDate.replace(/(\d{4})(\d{2})(\d{2})/, "$1-$2-$3"));
            const currentDate = new Date();
            const daysAgo = Math.floor((currentDate.getTime() - uploadDateFormatted.getTime()) /
                (1000 * 60 * 60 * 24));
            const prettyDate = new Date(uploadDate.replace(/(\d{4})(\d{2})(\d{2})/, "$1-$2-$3")).toLocaleDateString("en-US", {
                year: "numeric",
                month: "long",
                day: "numeric",
            });
            const uploadAgoObject = calculateUploadAgo(daysAgo);
            const videoTimeInSeconds = EnResp.metaTube.duration;
            const videoDuration = calculateVideoDuration(videoTimeInSeconds);
            const viewCountFormatted = formatCount(EnResp.metaTube.view_count);
            const likeCountFormatted = formatCount(EnResp.metaTube.like_count);
            function calculateUploadAgo(days) {
                const years = Math.floor(days / 365);
                const months = Math.floor((days % 365) / 30);
                const remainingDays = days % 30;
                const formattedString = `${years > 0 ? years + " years, " : ""}${months > 0 ? months + " months, " : ""}${remainingDays} days`;
                return {
                    years,
                    months,
                    days: remainingDays,
                    formatted: formattedString,
                };
            }
            function calculateVideoDuration(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = seconds % 60;
                const formattedString = `${hours > 0 ? hours + " hours, " : ""}${minutes > 0 ? minutes + " minutes, " : ""}${remainingSeconds} seconds`;
                return {
                    hours,
                    minutes,
                    seconds: remainingSeconds,
                    formatted: formattedString,
                };
            }
            function formatCount(count) {
                const abbreviations = ["K", "M", "B", "T"];
                for (let i = abbreviations.length - 1; i >= 0; i--) {
                    const size = Math.pow(10, (i + 1) * 3);
                    if (size <= count) {
                        const formattedCount = Math.round((count / size) * 10) / 10;
                        return `${formattedCount}${abbreviations[i]}`;
                    }
                }
                return `${count}`;
                z;
            }
            resolve({
                id: EnResp.metaTube.id,
                original_url: EnResp.metaTube.original_url,
                webpage_url: EnResp.metaTube.webpage_url,
                title: EnResp.metaTube.title,
                view_count: EnResp.metaTube.view_count,
                like_count: EnResp.metaTube.like_count,
                view_count_formatted: viewCountFormatted,
                like_count_formatted: likeCountFormatted,
                uploader: EnResp.metaTube.uploader,
                uploader_id: EnResp.metaTube.uploader_id,
                uploader_url: EnResp.metaTube.uploader_url,
                thumbnail: EnResp.metaTube.thumbnail,
                categories: EnResp.metaTube.categories,
                time: videoTimeInSeconds,
                duration: videoDuration,
                age_limit: EnResp.metaTube.age_limit,
                live_status: EnResp.metaTube.live_status,
                description: EnResp.metaTube.description,
                full_description: EnResp.metaTube.description,
                upload_date: prettyDate,
                upload_ago: daysAgo,
                upload_ago_formatted: uploadAgoObject,
                comment_count: EnResp.metaTube.comment_count,
                comment_count_formatted: formatCount(EnResp.metaTube.comment_count),
                channel_id: EnResp.metaTube.channel_id,
                channel_name: EnResp.metaTube.channel,
                channel_url: EnResp.metaTube.channel_url,
                channel_follower_count: EnResp.metaTube.channel_follower_count,
                channel_follower_count_formatted: formatCount(EnResp.metaTube.channel_follower_count),
            });
        }
        catch (error) {
            reject(error instanceof z.ZodError ? error.errors : error);
        }
    });
}

async function extract_playlist_videos({ playlistUrls, }) {
    try {
        const proTubeArr = [];
        const processedVideoIds = new Set();
        for (const url of playlistUrls) {
            const ispUrl = url.match(/list=([a-zA-Z0-9_-]+)/);
            if (!ispUrl) {
                console.error(colors.bold.red("ERROR: "), "Invalid YouTube Playlist URL:", url);
                continue;
            }
            const resp = (await scrape(ispUrl[1])).stdout;
            if (!resp) {
                console.error(colors.bold.red("ERROR: "), "Invalid Data Found For:", ispUrl[1]);
                continue;
            }
            for (let i = 0; i < resp.videos.length; i++) {
                try {
                    const videoId = resp.videos[i].videoId;
                    if (processedVideoIds.has(videoId))
                        continue;
                    const data = await Engine({ query: videoId });
                    if (data instanceof Array)
                        proTubeArr.push(...data);
                    else
                        proTubeArr.push(data);
                    processedVideoIds.add(videoId);
                }
                catch (error) {
                    console.error(colors.bold.red("ERROR: "), error);
                }
            }
        }
        return proTubeArr;
    }
    catch (error) {
        return error instanceof z.ZodError ? error.errors : error;
    }
}

function lowEntry(out) {
    if (!out || out.length === 0)
        return null;
    return out.reduce((prev, curr) => prev.meta_info.filesizebytes < curr.meta_info.filesizebytes ? prev : curr, out[0]);
}

const progressBar = (percent) => {
    if (percent === undefined)
        return;
    const completed = Math.round(50 * (percent / 100));
    const incomplete = 50 - completed;
    const completedStr = colors.bold.bgGreen(" ".repeat(completed));
    const incompleteStr = colors.bold.gray(" ".repeat(incomplete));
    const percentStr = colors.bold.blue(" " + percent.toFixed(2) + "% ");
    const progressBarString = new Date().toLocaleString() +
        colors.bold.blue(" INFO:") +
        " " +
        completedStr +
        incompleteStr +
        percentStr;
    readline.cursorTo(process.stdout, 0);
    process.stdout.write(progressBarString);
};

async function AudioLowest({ query, filter, stream, verbose, folderName, outputFormat = "mp3", }) {
    try {
        if (!query || typeof query !== "string") {
            return {
                message: "Invalid query parameter",
                status: 500,
            };
        }
        const metaBody = await Engine({ query });
        if (!metaBody) {
            return {
                message: "Unable to get response from YouTube...",
                status: 500,
            };
        }
        let metaName = "";
        const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
        const metaFold = folderName
            ? path.join(process.cwd(), folderName)
            : process.cwd();
        if (!fs.existsSync(metaFold))
            fs.mkdirSync(metaFold, { recursive: true });
        const metaEntry = lowEntry(metaBody.AudioTube);
        const ytc = fluentffmpeg();
        ytc.input(metaEntry.meta_dl.mediaurl);
        ytc.input(metaBody.metaTube.thumbnail);
        ytc.addOutputOption("-map", "1:0");
        ytc.addOutputOption("-map", "0:a:0");
        ytc.addOutputOption("-id3v2_version", "3");
        ytc.format(outputFormat);
        ytc.on("start", (cmd) => {
            if (verbose)
                console.log(cmd);
            progressBar(0);
        });
        ytc.on("end", () => progressBar(100));
        ytc.on("close", () => progressBar(100));
        ytc.on("progress", ({ percent }) => progressBar(percent));
        ytc.on("error", (error) => {
            return error;
        });
        switch (filter) {
            case "bassboost":
                ytc.withAudioFilter(["bass=g=10,dynaudnorm=f=150"]);
                metaName = `yt-core-(AudioLowest_bassboost)-${title}.${outputFormat}`;
                break;
            case "echo":
                ytc.withAudioFilter(["aecho=0.8:0.9:1000:0.3"]);
                metaName = `yt-core-(AudioLowest_echo)-${title}.${outputFormat}`;
                break;
            case "flanger":
                ytc.withAudioFilter(["flanger"]);
                metaName = `yt-core-(AudioLowest_flanger)-${title}.${outputFormat}`;
                break;
            case "nightcore":
                ytc.withAudioFilter(["aresample=48000,asetrate=48000*1.25"]);
                metaName = `yt-core-(AudioLowest_nightcore)-${title}.${outputFormat}`;
                break;
            case "panning":
                ytc.withAudioFilter(["apulsator=hz=0.08"]);
                metaName = `yt-core-(AudioLowest_panning)-${title}.${outputFormat}`;
                break;
            case "phaser":
                ytc.withAudioFilter(["aphaser=in_gain=0.4"]);
                metaName = `yt-core-(AudioLowest_phaser)-${title}.${outputFormat}`;
                break;
            case "reverse":
                ytc.withAudioFilter(["areverse"]);
                metaName = `yt-core-(AudioLowest_reverse)-${title}.${outputFormat}`;
                break;
            case "slow":
                ytc.withAudioFilter(["atempo=0.8"]);
                metaName = `yt-core-(AudioLowest_slow)-${title}.${outputFormat}`;
                break;
            case "speed":
                ytc.withAudioFilter(["atempo=2"]);
                metaName = `yt-core-(AudioLowest_speed)-${title}.${outputFormat}`;
                break;
            case "subboost":
                ytc.withAudioFilter(["asubboost"]);
                metaName = `yt-core-(AudioLowest_subboost)-${title}.${outputFormat}`;
                break;
            case "superslow":
                ytc.withAudioFilter(["atempo=0.5"]);
                metaName = `yt-core-(AudioLowest_superslow)-${title}.${outputFormat}`;
                break;
            case "superspeed":
                ytc.withAudioFilter(["atempo=3"]);
                metaName = `yt-core-(AudioLowest_superspeed)-${title}.${outputFormat}`;
                break;
            case "surround":
                ytc.withAudioFilter(["surround"]);
                metaName = `yt-core-(AudioLowest_surround)-${title}.${outputFormat}`;
                break;
            case "vaporwave":
                ytc.withAudioFilter(["aresample=48000,asetrate=48000*0.8"]);
                metaName = `yt-core-(AudioLowest_vaporwave)-${title}.${outputFormat}`;
                break;
            case "vibrato":
                ytc.withAudioFilter(["vibrato=f=6.5"]);
                metaName = `yt-core-(AudioLowest_vibrato)-${title}.${outputFormat}`;
                break;
            default:
                ytc.withAudioFilter([]);
                metaName = `yt-core-(AudioLowest)-${title}.${outputFormat}`;
                break;
        }
        if (stream) {
            const readStream = new Readable({
                read() { },
            });
            const writeStream = new Writable({
                write(chunk, _encoding, callback) {
                    readStream.push(chunk);
                    callback();
                },
                final(callback) {
                    readStream.push(null);
                    callback();
                },
            });
            ytc.pipe(writeStream, { end: true });
            return {
                stream: readStream,
                filename: folderName ? path.join(metaFold, metaName) : metaName,
            };
        }
        else {
            await new Promise((resolve, reject) => {
                ytc
                    .output(path.join(metaFold, metaName))
                    .on("error", reject)
                    .on("end", () => {
                    resolve();
                    return {
                        status: 200,
                        message: "process ended...",
                    };
                })
                    .run();
            });
            return {
                status: 200,
                message: "process ended...",
            };
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return {
                    message: error.message,
                    status: 500,
                };
            default:
                return {
                    message: "Internal server error",
                    status: 500,
                };
        }
    }
}

function bigEntry(out) {
    if (!out || out.length === 0)
        return null;
    return out.reduce((prev, curr) => prev.meta_info.filesizebytes > curr.meta_info.filesizebytes ? prev : curr, out[0]);
}

async function AudioHighest({ query, filter, stream, verbose, folderName, outputFormat = "mp3", }) {
    try {
        if (!query || typeof query !== "string") {
            return {
                message: "Invalid query parameter",
                status: 500,
            };
        }
        const metaBody = await Engine({ query });
        if (!metaBody) {
            return {
                message: "Unable to get response from YouTube...",
                status: 500,
            };
        }
        let metaName = "";
        const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
        const metaFold = folderName
            ? path.join(process.cwd(), folderName)
            : process.cwd();
        if (!fs.existsSync(metaFold))
            fs.mkdirSync(metaFold, { recursive: true });
        const metaEntry = bigEntry(metaBody.AudioTube);
        const ytc = fluentffmpeg();
        ytc.input(metaEntry.meta_dl.mediaurl);
        ytc.input(metaBody.metaTube.thumbnail);
        ytc.addOutputOption("-map", "1:0");
        ytc.addOutputOption("-map", "0:a:0");
        ytc.addOutputOption("-id3v2_version", "3");
        ytc.format(outputFormat);
        ytc.on("start", (cmd) => {
            if (verbose)
                console.log(cmd);
            progressBar(0);
        });
        ytc.on("end", () => progressBar(100));
        ytc.on("close", () => progressBar(100));
        ytc.on("progress", ({ percent }) => progressBar(percent));
        ytc.on("error", (error) => {
            return error;
        });
        switch (filter) {
            case "bassboost":
                ytc.withAudioFilter(["bass=g=10,dynaudnorm=f=150"]);
                metaName = `yt-core-(AudioHighest_bassboost)-${title}.${outputFormat}`;
                break;
            case "echo":
                ytc.withAudioFilter(["aecho=0.8:0.9:1000:0.3"]);
                metaName = `yt-core-(AudioHighest_echo)-${title}.${outputFormat}`;
                break;
            case "flanger":
                ytc.withAudioFilter(["flanger"]);
                metaName = `yt-core-(AudioHighest_flanger)-${title}.${outputFormat}`;
                break;
            case "nightcore":
                ytc.withAudioFilter(["aresample=48000,asetrate=48000*1.25"]);
                metaName = `yt-core-(AudioHighest_nightcore)-${title}.${outputFormat}`;
                break;
            case "panning":
                ytc.withAudioFilter(["apulsator=hz=0.08"]);
                metaName = `yt-core-(AudioHighest_panning)-${title}.${outputFormat}`;
                break;
            case "phaser":
                ytc.withAudioFilter(["aphaser=in_gain=0.4"]);
                metaName = `yt-core-(AudioHighest_phaser)-${title}.${outputFormat}`;
                break;
            case "reverse":
                ytc.withAudioFilter(["areverse"]);
                metaName = `yt-core-(AudioHighest_reverse)-${title}.${outputFormat}`;
                break;
            case "slow":
                ytc.withAudioFilter(["atempo=0.8"]);
                metaName = `yt-core-(AudioHighest_slow)-${title}.${outputFormat}`;
                break;
            case "speed":
                ytc.withAudioFilter(["atempo=2"]);
                metaName = `yt-core-(AudioHighest_speed)-${title}.${outputFormat}`;
                break;
            case "subboost":
                ytc.withAudioFilter(["asubboost"]);
                metaName = `yt-core-(AudioHighest_subboost)-${title}.${outputFormat}`;
                break;
            case "superslow":
                ytc.withAudioFilter(["atempo=0.5"]);
                metaName = `yt-core-(AudioHighest_superslow)-${title}.${outputFormat}`;
                break;
            case "superspeed":
                ytc.withAudioFilter(["atempo=3"]);
                metaName = `yt-core-(AudioHighest_superspeed)-${title}.${outputFormat}`;
                break;
            case "surround":
                ytc.withAudioFilter(["surround"]);
                metaName = `yt-core-(AudioHighest_surround)-${title}.${outputFormat}`;
                break;
            case "vaporwave":
                ytc.withAudioFilter(["aresample=48000,asetrate=48000*0.8"]);
                metaName = `yt-core-(AudioHighest_vaporwave)-${title}.${outputFormat}`;
                break;
            case "vibrato":
                ytc.withAudioFilter(["vibrato=f=6.5"]);
                metaName = `yt-core-(AudioHighest_vibrato)-${title}.${outputFormat}`;
                break;
            default:
                ytc.withAudioFilter([]);
                metaName = `yt-core-(AudioHighest)-${title}.${outputFormat}`;
                break;
        }
        if (stream) {
            const readStream = new Readable({
                read() { },
            });
            const writeStream = new Writable({
                write(chunk, _encoding, callback) {
                    readStream.push(chunk);
                    callback();
                },
                final(callback) {
                    readStream.push(null);
                    callback();
                },
            });
            ytc.pipe(writeStream, { end: true });
            return {
                stream: readStream,
                filename: folderName ? path.join(metaFold, metaName) : metaName,
            };
        }
        else {
            await new Promise((resolve, reject) => {
                ytc
                    .output(path.join(metaFold, metaName))
                    .on("error", reject)
                    .on("end", () => {
                    resolve();
                    return {
                        status: 200,
                        message: "process ended...",
                    };
                })
                    .run();
            });
            return {
                status: 200,
                message: "process ended...",
            };
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return {
                    message: error.message,
                    status: 500,
                };
            default:
                return {
                    message: "Internal server error",
                    status: 500,
                };
        }
    }
}

async function VideoLowest({ query, filter, stream, verbose, folderName, outputFormat = "mp4", }) {
    try {
        if (!query || typeof query !== "string") {
            return {
                message: "Invalid query parameter",
                status: 500,
            };
        }
        const metaBody = await Engine({ query });
        if (!metaBody) {
            return {
                message: "Unable to get response from YouTube...",
                status: 500,
            };
        }
        let metaName = "";
        const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
        const metaFold = folderName
            ? path.join(process.cwd(), folderName)
            : process.cwd();
        if (!fs.existsSync(metaFold))
            fs.mkdirSync(metaFold, { recursive: true });
        const metaEntry = lowEntry(metaBody.VideoTube);
        const ytc = fluentffmpeg();
        ytc.input(metaEntry.meta_dl.mediaurl);
        ytc.format(outputFormat);
        switch (filter) {
            case "grayscale":
                ytc.videoFilters("colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3");
                metaName = `yt-core_(VideoLowest-grayscale)_${title}.${outputFormat}`;
                break;
            case "invert":
                ytc.videoFilters("negate");
                metaName = `yt-core_(VideoLowest-invert)_${title}.${outputFormat}`;
                break;
            case "rotate90":
                ytc.videoFilters("rotate=PI/2");
                metaName = `yt-core_(VideoLowest-rotate90)_${title}.${outputFormat}`;
                break;
            case "rotate180":
                ytc.videoFilters("rotate=PI");
                metaName = `yt-core_(VideoLowest-rotate180)_${title}.${outputFormat}`;
                break;
            case "rotate270":
                ytc.videoFilters("rotate=3*PI/2");
                metaName = `yt-core_(VideoLowest-rotate270)_${title}.${outputFormat}`;
                break;
            case "flipHorizontal":
                ytc.videoFilters("hflip");
                metaName = `yt-core_(VideoLowest-flipHorizontal)_${title}.${outputFormat}`;
                break;
            case "flipVertical":
                ytc.videoFilters("vflip");
                metaName = `yt-core_(VideoLowest-flipVertical)_${title}.${outputFormat}`;
                break;
            default:
                metaName = `yt-core_(VideoLowest)_${title}.${outputFormat}`;
        }
        ytc.on("start", (cmd) => {
            if (verbose)
                console.log(cmd);
            progressBar(0);
        });
        ytc.on("end", () => progressBar(100));
        ytc.on("close", () => progressBar(100));
        ytc.on("progress", ({ percent }) => progressBar(percent));
        ytc.on("error", (error) => {
            return error;
        });
        switch (stream) {
            case true:
                const readStream = new Readable({
                    read() { },
                });
                const writeStream = new Writable({
                    write(chunk, _encoding, callback) {
                        readStream.push(chunk);
                        callback();
                    },
                    final(callback) {
                        readStream.push(null);
                        callback();
                    },
                });
                ytc.pipe(writeStream, { end: true });
                return {
                    stream: readStream,
                    filename: folderName ? path.join(metaFold, metaName) : metaName,
                };
            default:
                await new Promise((resolve, reject) => {
                    ytc
                        .output(path.join(metaFold, metaName))
                        .on("error", reject)
                        .on("end", () => {
                        resolve();
                    })
                        .run();
                });
                return {
                    message: "process ended...",
                    status: 200,
                };
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return {
                    message: error.message,
                    status: 500,
                };
            default:
                return {
                    message: "Internal server error",
                    status: 500,
                };
        }
    }
}

async function VideoHighest({ query, filter, stream, verbose, folderName, outputFormat = "mp4", }) {
    try {
        if (!query || typeof query !== "string") {
            return {
                message: "Invalid query parameter",
                status: 500,
            };
        }
        const metaBody = await Engine({ query });
        if (!metaBody) {
            return {
                message: "Unable to get response from YouTube...",
                status: 500,
            };
        }
        let metaName = "";
        const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
        const metaFold = folderName
            ? path.join(process.cwd(), folderName)
            : process.cwd();
        if (!fs.existsSync(metaFold))
            fs.mkdirSync(metaFold, { recursive: true });
        const metaEntry = bigEntry(metaBody.VideoTube);
        const ytc = fluentffmpeg();
        ytc.input(metaEntry.meta_dl.mediaurl);
        ytc.format(outputFormat);
        switch (filter) {
            case "grayscale":
                ytc.videoFilters("colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3");
                metaName = `yt-core_(VideoHighest-grayscale)_${title}.${outputFormat}`;
                break;
            case "invert":
                ytc.videoFilters("negate");
                metaName = `yt-core_(VideoHighest-invert)_${title}.${outputFormat}`;
                break;
            case "rotate90":
                ytc.videoFilters("rotate=PI/2");
                metaName = `yt-core_(VideoHighest-rotate90)_${title}.${outputFormat}`;
                break;
            case "rotate180":
                ytc.videoFilters("rotate=PI");
                metaName = `yt-core_(VideoHighest-rotate180)_${title}.${outputFormat}`;
                break;
            case "rotate270":
                ytc.videoFilters("rotate=3*PI/2");
                metaName = `yt-core_(VideoHighest-rotate270)_${title}.${outputFormat}`;
                break;
            case "flipHorizontal":
                ytc.videoFilters("hflip");
                metaName = `yt-core_(VideoHighest-flipHorizontal)_${title}.${outputFormat}`;
                break;
            case "flipVertical":
                ytc.videoFilters("vflip");
                metaName = `yt-core_(VideoHighest-flipVertical)_${title}.${outputFormat}`;
                break;
            default:
                metaName = `yt-core_(VideoHighest)_${title}.${outputFormat}`;
        }
        ytc.on("start", (cmd) => {
            if (verbose)
                console.log(cmd);
            progressBar(0);
        });
        ytc.on("end", () => progressBar(100));
        ytc.on("close", () => progressBar(100));
        ytc.on("progress", ({ percent }) => progressBar(percent));
        ytc.on("error", (error) => {
            return error;
        });
        switch (stream) {
            case true:
                const readStream = new Readable({
                    read() { },
                });
                const writeStream = new Writable({
                    write(chunk, _encoding, callback) {
                        readStream.push(chunk);
                        callback();
                    },
                    final(callback) {
                        readStream.push(null);
                        callback();
                    },
                });
                ytc.pipe(writeStream, { end: true });
                return {
                    stream: readStream,
                    filename: folderName ? path.join(metaFold, metaName) : metaName,
                };
            default:
                await new Promise((resolve, reject) => {
                    ytc
                        .output(path.join(metaFold, metaName))
                        .on("error", reject)
                        .on("end", () => {
                        resolve();
                    })
                        .run();
                });
                return {
                    message: "process ended...",
                    status: 200,
                };
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return {
                    message: error.message,
                    status: 500,
                };
            default:
                return {
                    message: "Internal server error",
                    status: 500,
                };
        }
    }
}

async function AudioVideoLowest({ query, stream, verbose, folderName, outputFormat = "mp4", }) {
    try {
        if (!query || typeof query !== "string") {
            return {
                message: "Invalid query parameter",
                status: 500,
            };
        }
        const metaBody = await Engine({ query });
        if (!metaBody) {
            return {
                message: "Unable to get response from YouTube...",
                status: 500,
            };
        }
        const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
        let metaName = `yt-core_(AudioVideoLowest)_${title}.${outputFormat}`;
        const metaFold = folderName
            ? path.join(process.cwd(), folderName)
            : process.cwd();
        if (!fs.existsSync(metaFold))
            fs.mkdirSync(metaFold, { recursive: true });
        const ytc = fluentffmpeg();
        ytc.input(lowEntry(metaBody.VideoTube).meta_dl.mediaurl);
        ytc.input(lowEntry(metaBody.AudioTube).meta_dl.mediaurl);
        ytc.format(outputFormat);
        ytc.on("start", (cmd) => {
            if (verbose)
                console.log(cmd);
            progressBar(0);
        });
        ytc.on("end", () => progressBar(100));
        ytc.on("close", () => progressBar(100));
        ytc.on("progress", ({ percent }) => progressBar(percent));
        ytc.on("error", (error) => {
            return error;
        });
        if (stream) {
            const readStream = new Readable({
                read() { },
            });
            const writeStream = new Writable({
                write(chunk, _encoding, callback) {
                    readStream.push(chunk);
                    callback();
                },
                final(callback) {
                    readStream.push(null);
                    callback();
                },
            });
            ytc.pipe(writeStream, { end: true });
            return {
                stream: readStream,
                filename: folderName ? path.join(metaFold, metaName) : metaName,
            };
        }
        else {
            await new Promise((resolve, reject) => {
                ytc
                    .output(path.join(metaFold, metaName))
                    .on("error", reject)
                    .on("end", () => {
                    resolve();
                    return {
                        status: 200,
                        message: "process ended...",
                    };
                })
                    .run();
            });
            return {
                status: 200,
                message: "process ended...",
            };
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return {
                    message: error.message,
                    status: 500,
                };
            default:
                return {
                    message: "Internal server error",
                    status: 500,
                };
        }
    }
}

async function AudioVideoHighest({ query, stream, verbose, folderName, outputFormat = "mp4", }) {
    try {
        if (!query || typeof query !== "string") {
            return {
                message: "Invalid query parameter",
                status: 500,
            };
        }
        const metaBody = await Engine({ query });
        if (!metaBody) {
            return {
                message: "Unable to get response from YouTube...",
                status: 500,
            };
        }
        const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
        let metaName = `yt-core_(AudioVideoHighest)_${title}.${outputFormat}`;
        const metaFold = folderName
            ? path.join(process.cwd(), folderName)
            : process.cwd();
        if (!fs.existsSync(metaFold))
            fs.mkdirSync(metaFold, { recursive: true });
        const ytc = fluentffmpeg();
        ytc.input(bigEntry(metaBody.VideoTube).meta_dl.mediaurl);
        ytc.input(bigEntry(metaBody.AudioTube).meta_dl.mediaurl);
        ytc.format(outputFormat);
        ytc.on("start", (cmd) => {
            if (verbose)
                console.log(cmd);
            progressBar(0);
        });
        ytc.on("end", () => progressBar(100));
        ytc.on("close", () => progressBar(100));
        ytc.on("progress", ({ percent }) => progressBar(percent));
        ytc.on("error", (error) => {
            return error;
        });
        if (stream) {
            const readStream = new Readable({
                read() { },
            });
            const writeStream = new Writable({
                write(chunk, _encoding, callback) {
                    readStream.push(chunk);
                    callback();
                },
                final(callback) {
                    readStream.push(null);
                    callback();
                },
            });
            ytc.pipe(writeStream, { end: true });
            return {
                stream: readStream,
                filename: folderName ? path.join(metaFold, metaName) : metaName,
            };
        }
        else {
            await new Promise((resolve, reject) => {
                ytc
                    .output(path.join(metaFold, metaName))
                    .on("error", reject)
                    .on("end", () => {
                    resolve();
                    return {
                        status: 200,
                        message: "process ended...",
                    };
                })
                    .run();
            });
            return {
                status: 200,
                message: "process ended...",
            };
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return {
                    message: error.message,
                    status: 500,
                };
            default:
                return {
                    message: "Internal server error",
                    status: 500,
                };
        }
    }
}

async function AudioQualityCustom({ query, filter, quality, stream, folderName, outputFormat = "mp3", }) {
    try {
        if (!query ||
            typeof query !== "string" ||
            !quality ||
            typeof quality !== "string") {
            return {
                message: "Invalid query or quality parameter",
                status: 500,
            };
        }
        const metaResp = await Engine({ query });
        if (!metaResp) {
            return {
                message: "The specified quality was not found...",
                status: 500,
            };
        }
        const metaBody = metaResp.AudioTube.filter((op) => op.meta_dl.formatnote === quality);
        if (!metaBody) {
            return {
                message: "Unable to get response from YouTube...",
                status: 500,
            };
        }
        const title = metaResp.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
        const metaFold = folderName
            ? path.join(process.cwd(), folderName)
            : process.cwd();
        if (!fs.existsSync(metaFold))
            fs.mkdirSync(metaFold, { recursive: true });
        const ytc = fluentffmpeg();
        const metaEntry = bigEntry(metaBody);
        ytc.input(metaEntry.meta_dl.mediaurl);
        ytc.input(metaResp.metaTube.thumbnail);
        ytc.addOutputOption("-map", "1:0");
        ytc.addOutputOption("-map", "0:a:0");
        ytc.addOutputOption("-id3v2_version", "3");
        ytc.withAudioBitrate(metaEntry.meta_audio.bitrate);
        ytc.withAudioChannels(metaEntry.meta_audio.channels);
        ytc.format(outputFormat);
        switch (filter) {
            case "bassboost":
                ytc.withAudioFilter(["bass=g=10,dynaudnorm=f=150"]);
                break;
            case "echo":
                ytc.withAudioFilter(["aecho=0.8:0.9:1000:0.3"]);
                break;
            case "flanger":
                ytc.withAudioFilter(["flanger"]);
                break;
            case "nightcore":
                ytc.withAudioFilter(["aresample=48000,asetrate=48000*1.25"]);
                break;
            case "panning":
                ytc.withAudioFilter(["apulsator=hz=0.08"]);
                break;
            case "phaser":
                ytc.withAudioFilter(["aphaser=in_gain=0.4"]);
                break;
            case "reverse":
                ytc.withAudioFilter(["areverse"]);
                break;
            case "slow":
                ytc.withAudioFilter(["atempo=0.8"]);
                break;
            case "speed":
                ytc.withAudioFilter(["atempo=2"]);
                break;
            case "subboost":
                ytc.withAudioFilter(["asubboost"]);
                break;
            case "superslow":
                ytc.withAudioFilter(["atempo=0.5"]);
                break;
            case "superspeed":
                ytc.withAudioFilter(["atempo=3"]);
                break;
            case "surround":
                ytc.withAudioFilter(["surround"]);
                break;
            case "vaporwave":
                ytc.withAudioFilter(["aresample=48000,asetrate=48000*0.8"]);
                break;
            case "vibrato":
                ytc.withAudioFilter(["vibrato=f=6.5"]);
                break;
            default:
                ytc.withAudioFilter([]);
                break;
        }
        ytc.on("start", () => progressBar(0));
        ytc.on("end", () => progressBar(100));
        ytc.on("close", () => progressBar(100));
        ytc.on("progress", ({ percent }) => progressBar(percent));
        ytc.on("error", (error) => {
            return error;
        });
        if (stream) {
            const readStream = new Readable({
                read() { },
            });
            const writeStream = new Writable({
                write(chunk, _encoding, callback) {
                    readStream.push(chunk);
                    callback();
                },
                final(callback) {
                    readStream.push(null);
                    callback();
                },
            });
            ytc.pipe(writeStream, { end: true });
            return {
                stream: readStream,
                filename: folderName
                    ? path.join(metaFold, `yt-core-(${quality})-${title}.${outputFormat}`)
                    : `yt-core-(${quality})-${title}.${outputFormat}`,
            };
        }
        else {
            await new Promise((resolve, reject) => {
                ytc
                    .output(path.join(metaFold, `yt-core-(${quality})-${title}.${outputFormat}`))
                    .on("error", reject)
                    .on("end", () => {
                    resolve();
                })
                    .run();
            });
            return {
                message: "process ended...",
                status: 200,
            };
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return {
                    message: error.message,
                    status: 500,
                };
            default:
                return {
                    message: "Internal server error",
                    status: 500,
                };
        }
    }
}

async function VideoQualityCustom({ query, filter, quality, stream, folderName, outputFormat = "mp4", }) {
    try {
        if (!query ||
            typeof query !== "string" ||
            !quality ||
            typeof quality !== "string") {
            return {
                message: "Invalid query or quality parameter",
                status: 500,
            };
        }
        const EnResp = await Engine({ query });
        if (!EnResp) {
            return {
                message: "The specified quality was not found...",
                status: 500,
            };
        }
        const YSBody = EnResp.VideoTube.filter((op) => op.meta_dl.formatnote === quality);
        if (!YSBody) {
            return {
                message: "Unable to get response from YouTube...",
                status: 500,
            };
        }
        else {
            let ipop = "";
            const title = EnResp.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
            const opfol = folderName
                ? path.join(process.cwd(), folderName)
                : process.cwd();
            if (!fs.existsSync(opfol))
                fs.mkdirSync(opfol, { recursive: true });
            const ytc = fluentffmpeg();
            const metaEntry = bigEntry(YSBody);
            ytc.input(metaEntry.meta_dl.mediaurl);
            ytc.format(outputFormat);
            switch (filter) {
                case "grayscale":
                    ytc.withVideoFilter([
                        "colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3",
                    ]);
                    ipop = `yt-core_(VideoQualityCustom-grayscale)_${title}.${outputFormat}`;
                    break;
                case "invert":
                    ytc.withVideoFilter(["negate"]);
                    ipop = `yt-core_(VideoQualityCustom-invert)_${title}.${outputFormat}`;
                    break;
                case "rotate90":
                    ytc.withVideoFilter(["rotate=PI/2"]);
                    ipop = `yt-core_(VideoQualityCustom-rotate90)_${title}.${outputFormat}`;
                    break;
                case "rotate180":
                    ytc.withVideoFilter(["rotate=PI"]);
                    ipop = `yt-core_(VideoQualityCustom-rotate180)_${title}.${outputFormat}`;
                    break;
                case "rotate270":
                    ytc.withVideoFilter(["rotate=3*PI/2"]);
                    ipop = `yt-core_(VideoQualityCustom-rotate270)_${title}.${outputFormat}`;
                    break;
                case "flipHorizontal":
                    ytc.withVideoFilter(["hflip"]);
                    ipop = `yt-core_(VideoQualityCustom-flipHorizontal)_${title}.${outputFormat}`;
                    break;
                case "flipVertical":
                    ytc.withVideoFilter(["vflip"]);
                    ipop = `yt-core_(VideoQualityCustom-flipVertical)_${title}.${outputFormat}`;
                    break;
                default:
                    ytc.withVideoFilter([]);
                    ipop = `yt-core_(VideoQualityCustom)_${title}.${outputFormat}`;
            }
            ytc.on("start", () => {
                progressBar(0);
            });
            ytc.on("end", () => progressBar(100));
            ytc.on("close", () => progressBar(100));
            ytc.on("progress", ({ percent }) => progressBar(percent));
            ytc.on("error", (error) => {
                return error;
            });
            if (stream) {
                const readStream = new Readable({
                    read() { },
                });
                const writeStream = new Writable({
                    write(chunk, _encoding, callback) {
                        readStream.push(chunk);
                        callback();
                    },
                    final(callback) {
                        readStream.push(null);
                        callback();
                    },
                });
                ytc.pipe(writeStream, { end: true });
                return {
                    stream: readStream,
                    filename: folderName ? path.join(opfol, ipop) : ipop,
                };
            }
            else {
                await new Promise((resolve, reject) => {
                    ytc
                        .output(path.join(opfol, ipop))
                        .on("error", reject)
                        .on("end", () => {
                        resolve();
                    })
                        .run();
                });
                return {
                    message: "process ended...",
                    status: 200,
                };
            }
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return {
                    message: error.message,
                    status: 500,
                };
            default:
                return {
                    message: "Internal server error",
                    status: 500,
                };
        }
    }
}

async function ListVideoLowest({ filter, stream, verbose, folderName, playlistUrls, outputFormat = "mp4", }) {
    try {
        if (!Array.isArray(playlistUrls) ||
            !playlistUrls.every((url) => typeof url === "string")) {
            return [
                {
                    message: "Invalid playlistUrls[] parameter. Expecting an array of strings.",
                    status: 500,
                },
            ];
        }
        const videos = await get_playlist({
            playlistUrls,
        });
        if (!videos) {
            return [
                {
                    message: "Unable to get response from YouTube...",
                    status: 500,
                },
            ];
        }
        else {
            const results = [];
            await async.eachSeries(videos, async (video) => {
                try {
                    const metaBody = await Engine({ query: video.url });
                    if (!metaBody) {
                        throw new Error("Unable to get response from YouTube...");
                    }
                    let metaName = "";
                    const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
                    const metaFold = folderName
                        ? path.join(process.cwd(), folderName)
                        : process.cwd();
                    if (!fs.existsSync(metaFold))
                        fs.mkdirSync(metaFold, { recursive: true });
                    const metaEntry = lowEntry(metaBody.VideoTube);
                    const ytc = fluentffmpeg();
                    ytc.input(metaEntry.meta_dl.mediaurl);
                    ytc.format(outputFormat);
                    ytc.on("start", (cmd) => {
                        if (verbose)
                            console.log(cmd);
                        progressBar(0);
                    });
                    ytc.on("end", () => progressBar(100));
                    ytc.on("close", () => progressBar(100));
                    ytc.on("progress", ({ percent }) => progressBar(percent));
                    switch (filter) {
                        case "grayscale":
                            ytc.videoFilters("colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3");
                            metaName = `yt-core_(VideoLowest-grayscale)_${title}.${outputFormat}`;
                            break;
                        case "invert":
                            ytc.videoFilters("negate");
                            metaName = `yt-core_(VideoLowest-invert)_${title}.${outputFormat}`;
                            break;
                        case "rotate90":
                            ytc.videoFilters("rotate=PI/2");
                            metaName = `yt-core_(VideoLowest-rotate90)_${title}.${outputFormat}`;
                            break;
                        case "rotate180":
                            ytc.videoFilters("rotate=PI");
                            metaName = `yt-core_(VideoLowest-rotate180)_${title}.${outputFormat}`;
                            break;
                        case "rotate270":
                            ytc.videoFilters("rotate=3*PI/2");
                            metaName = `yt-core_(VideoLowest-rotate270)_${title}.${outputFormat}`;
                            break;
                        case "flipHorizontal":
                            ytc.videoFilters("hflip");
                            metaName = `yt-core_(VideoLowest-flipHorizontal)_${title}.${outputFormat}`;
                            break;
                        case "flipVertical":
                            ytc.videoFilters("vflip");
                            metaName = `yt-core_(VideoLowest-flipVertical)_${title}.${outputFormat}`;
                            break;
                        default:
                            metaName = `yt-core_(VideoLowest)_${title}.${outputFormat}`;
                    }
                    if (stream) {
                        const readStream = new Readable({
                            read() { },
                        });
                        const writeStream = new Writable({
                            write(chunk, _encoding, callback) {
                                readStream.push(chunk);
                                callback();
                            },
                            final(callback) {
                                readStream.push(null);
                                callback();
                            },
                        });
                        ytc.pipe(writeStream, { end: true });
                        results.push({
                            stream: readStream,
                            filename: folderName ? path.join(metaFold, metaName) : metaName,
                        });
                    }
                    else {
                        await new Promise((resolve, reject) => {
                            ytc
                                .output(path.join(metaFold, metaName))
                                .on("end", () => resolve())
                                .on("error", reject)
                                .run();
                        });
                    }
                }
                catch (error) {
                    results.push({
                        status: 500,
                        message: colors.bold.red("ERROR: ") + video.title,
                    });
                }
            });
            return results;
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return [
                    {
                        message: error.message,
                        status: 500,
                    },
                ];
            default:
                return [
                    {
                        message: "Internal server error",
                        status: 500,
                    },
                ];
        }
    }
}

async function ListVideoHighest({ filter, stream, verbose, folderName, playlistUrls, outputFormat = "mp4", }) {
    try {
        if (!Array.isArray(playlistUrls) ||
            !playlistUrls.every((url) => typeof url === "string")) {
            return [
                {
                    message: "Invalid playlistUrls[] parameter. Expecting an array of strings.",
                    status: 500,
                },
            ];
        }
        const videos = await get_playlist({
            playlistUrls,
        });
        if (!videos) {
            return [
                {
                    message: "Unable to get response from YouTube...",
                    status: 500,
                },
            ];
        }
        else {
            const results = [];
            await async.eachSeries(videos, async (video) => {
                try {
                    const metaBody = await Engine({ query: video.url });
                    if (!metaBody) {
                        throw new Error("Unable to get response from YouTube...");
                    }
                    let metaName = "";
                    const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
                    const metaFold = folderName
                        ? path.join(process.cwd(), folderName)
                        : process.cwd();
                    if (!fs.existsSync(metaFold))
                        fs.mkdirSync(metaFold, { recursive: true });
                    const metaEntry = bigEntry(metaBody.VideoTube);
                    const ytc = fluentffmpeg();
                    ytc.input(metaEntry.meta_dl.mediaurl);
                    ytc.format(outputFormat);
                    ytc.on("start", (cmd) => {
                        if (verbose)
                            console.log(cmd);
                        progressBar(0);
                    });
                    ytc.on("end", () => progressBar(100));
                    ytc.on("close", () => progressBar(100));
                    ytc.on("progress", ({ percent }) => progressBar(percent));
                    switch (filter) {
                        case "grayscale":
                            ytc.videoFilters("colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3");
                            metaName = `yt-core_(VideoHighest-grayscale)_${title}.${outputFormat}`;
                            break;
                        case "invert":
                            ytc.videoFilters("negate");
                            metaName = `yt-core_(VideoHighest-invert)_${title}.${outputFormat}`;
                            break;
                        case "rotate90":
                            ytc.videoFilters("rotate=PI/2");
                            metaName = `yt-core_(VideoHighest-rotate90)_${title}.${outputFormat}`;
                            break;
                        case "rotate180":
                            ytc.videoFilters("rotate=PI");
                            metaName = `yt-core_(VideoHighest-rotate180)_${title}.${outputFormat}`;
                            break;
                        case "rotate270":
                            ytc.videoFilters("rotate=3*PI/2");
                            metaName = `yt-core_(VideoHighest-rotate270)_${title}.${outputFormat}`;
                            break;
                        case "flipHorizontal":
                            ytc.videoFilters("hflip");
                            metaName = `yt-core_(VideoHighest-flipHorizontal)_${title}.${outputFormat}`;
                            break;
                        case "flipVertical":
                            ytc.videoFilters("vflip");
                            metaName = `yt-core_(VideoHighest-flipVertical)_${title}.${outputFormat}`;
                            break;
                        default:
                            metaName = `yt-core_(VideoHighest)_${title}.${outputFormat}`;
                    }
                    if (stream) {
                        const readStream = new Readable({
                            read() { },
                        });
                        const writeStream = new Writable({
                            write(chunk, _encoding, callback) {
                                readStream.push(chunk);
                                callback();
                            },
                            final(callback) {
                                readStream.push(null);
                                callback();
                            },
                        });
                        ytc.pipe(writeStream, { end: true });
                        results.push({
                            stream: readStream,
                            filename: folderName ? path.join(metaFold, metaName) : metaName,
                        });
                    }
                    else {
                        await new Promise((resolve, reject) => {
                            ytc
                                .output(path.join(metaFold, metaName))
                                .on("end", () => resolve())
                                .on("error", reject)
                                .run();
                        });
                    }
                }
                catch (error) {
                    results.push({
                        status: 500,
                        message: colors.bold.red("ERROR: ") + video.title,
                    });
                }
            });
            return results;
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return [
                    {
                        message: error.message,
                        status: 500,
                    },
                ];
            default:
                return [
                    {
                        message: "Internal server error",
                        status: 500,
                    },
                ];
        }
    }
}

async function ListVideoQualityCustom({ filter, stream, quality, verbose, folderName, playlistUrls, outputFormat = "mp4", }) {
    try {
        if (!Array.isArray(playlistUrls) ||
            !playlistUrls.every((url) => typeof url === "string")) {
            return [
                {
                    message: "Invalid playlistUrls[] parameter. Expecting an array of strings.",
                    status: 500,
                },
            ];
        }
        const videos = await get_playlist({
            playlistUrls,
        });
        if (!videos) {
            return [
                {
                    message: "Unable to get response from YouTube...",
                    status: 500,
                },
            ];
        }
        else {
            const results = [];
            await async.eachSeries(videos, async (video) => {
                try {
                    let metaBody;
                    metaBody = await Engine({ query: video.url });
                    if (!metaBody) {
                        results.push({
                            message: "Unable to get response from YouTube...",
                            status: 500,
                        });
                    }
                    else {
                        metaBody = metaBody.VideoTube.filter((op) => op.meta_dl.formatnote === quality);
                        if (!metaBody) {
                            results.push({
                                message: "Unable to get response from YouTube...",
                                status: 500,
                            });
                        }
                        else {
                            let metaName = "";
                            const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
                            const metaFold = folderName
                                ? path.join(process.cwd(), folderName)
                                : process.cwd();
                            if (!fs.existsSync(metaFold))
                                fs.mkdirSync(metaFold, { recursive: true });
                            const metaEntry = bigEntry(metaBody.VideoTube);
                            const ytc = fluentffmpeg();
                            ytc.input(metaEntry.meta_dl.mediaurl);
                            ytc.format(outputFormat);
                            ytc.on("start", (cmd) => {
                                if (verbose)
                                    console.log(cmd);
                                progressBar(0);
                            });
                            ytc.on("end", () => progressBar(100));
                            ytc.on("close", () => progressBar(100));
                            ytc.on("progress", ({ percent }) => progressBar(percent));
                            switch (filter) {
                                case "grayscale":
                                    ytc.withVideoFilter([
                                        "colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3",
                                    ]);
                                    metaName = `yt-core_(VideoQualityCustom-grayscale)_${title}.${outputFormat}`;
                                    break;
                                case "invert":
                                    ytc.withVideoFilter(["negate"]);
                                    metaName = `yt-core_(VideoQualityCustom-invert)_${title}.${outputFormat}`;
                                    break;
                                case "rotate90":
                                    ytc.withVideoFilter(["rotate=PI/2"]);
                                    metaName = `yt-core_(VideoQualityCustom-rotate90)_${title}.${outputFormat}`;
                                    break;
                                case "rotate180":
                                    ytc.withVideoFilter(["rotate=PI"]);
                                    metaName = `yt-core_(VideoQualityCustom-rotate180)_${title}.${outputFormat}`;
                                    break;
                                case "rotate270":
                                    ytc.withVideoFilter(["rotate=3*PI/2"]);
                                    metaName = `yt-core_(VideoQualityCustom-rotate270)_${title}.${outputFormat}`;
                                    break;
                                case "flipHorizontal":
                                    ytc.withVideoFilter(["hflip"]);
                                    metaName = `yt-core_(VideoQualityCustom-flipHorizontal)_${title}.${outputFormat}`;
                                    break;
                                case "flipVertical":
                                    ytc.withVideoFilter(["vflip"]);
                                    metaName = `yt-core_(VideoQualityCustom-flipVertical)_${title}.${outputFormat}`;
                                    break;
                                default:
                                    ytc.withVideoFilter([]);
                                    metaName = `yt-core_(VideoQualityCustom)_${title}.${outputFormat}`;
                            }
                            if (stream) {
                                const readStream = new Readable({
                                    read() { },
                                });
                                const writeStream = new Writable({
                                    write(chunk, _encoding, callback) {
                                        readStream.push(chunk);
                                        callback();
                                    },
                                    final(callback) {
                                        readStream.push(null);
                                        callback();
                                    },
                                });
                                ytc.pipe(writeStream, { end: true });
                                results.push({
                                    stream: readStream,
                                    filename: folderName
                                        ? path.join(metaFold, metaName)
                                        : metaName,
                                });
                            }
                            else {
                                await new Promise((resolve, reject) => {
                                    ytc
                                        .output(path.join(metaFold, metaName))
                                        .on("end", () => resolve())
                                        .on("error", reject)
                                        .run();
                                });
                            }
                        }
                    }
                }
                catch (error) {
                    results.push({
                        status: 500,
                        message: colors.bold.red("ERROR: ") + video.title,
                    });
                }
            });
            return results;
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return [
                    {
                        message: error.message,
                        status: 500,
                    },
                ];
            default:
                return [
                    {
                        message: "Internal server error",
                        status: 500,
                    },
                ];
        }
    }
}

async function ListAudioLowest({ filter, stream, verbose, folderName, playlistUrls, outputFormat = "mp3", }) {
    try {
        if (!Array.isArray(playlistUrls) ||
            !playlistUrls.every((url) => typeof url === "string")) {
            return [
                {
                    message: "Invalid playlistUrls[] parameter. Expecting an array of strings.",
                    status: 500,
                },
            ];
        }
        const videos = await get_playlist({
            playlistUrls,
        });
        if (!videos) {
            return [
                {
                    message: "Unable to get response from YouTube...",
                    status: 500,
                },
            ];
        }
        else {
            const results = [];
            await async.eachSeries(videos, async (video) => {
                try {
                    const metaBody = await Engine({ query: video.url });
                    if (!metaBody) {
                        throw new Error("Unable to get response from YouTube...");
                    }
                    let metaName = "";
                    const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
                    const metaFold = folderName
                        ? path.join(process.cwd(), folderName)
                        : process.cwd();
                    if (!fs.existsSync(metaFold))
                        fs.mkdirSync(metaFold, { recursive: true });
                    const metaEntry = lowEntry(metaBody.AudioTube);
                    const ytc = fluentffmpeg();
                    ytc.input(metaEntry.meta_dl.mediaurl);
                    ytc.input(metaBody.metaTube.thumbnail);
                    ytc.addOutputOption("-map", "1:0");
                    ytc.addOutputOption("-map", "0:a:0");
                    ytc.addOutputOption("-id3v2_version", "3");
                    ytc.format(outputFormat);
                    ytc.on("start", (cmd) => {
                        if (verbose)
                            console.log(cmd);
                        progressBar(0);
                    });
                    ytc.on("end", () => progressBar(100));
                    ytc.on("close", () => progressBar(100));
                    ytc.on("progress", ({ percent }) => progressBar(percent));
                    switch (filter) {
                        case "bassboost":
                            ytc.withAudioFilter(["bass=g=10,dynaudnorm=f=150"]);
                            metaName = `yt-core-(AudioLowest_bassboost)-${title}.${outputFormat}`;
                            break;
                        case "echo":
                            ytc.withAudioFilter(["aecho=0.8:0.9:1000:0.3"]);
                            metaName = `yt-core-(AudioLowest_echo)-${title}.${outputFormat}`;
                            break;
                        case "flanger":
                            ytc.withAudioFilter(["flanger"]);
                            metaName = `yt-core-(AudioLowest_flanger)-${title}.${outputFormat}`;
                            break;
                        case "nightcore":
                            ytc.withAudioFilter(["aresample=48000,asetrate=48000*1.25"]);
                            metaName = `yt-core-(AudioLowest_nightcore)-${title}.${outputFormat}`;
                            break;
                        case "panning":
                            ytc.withAudioFilter(["apulsator=hz=0.08"]);
                            metaName = `yt-core-(AudioLowest_panning)-${title}.${outputFormat}`;
                            break;
                        case "phaser":
                            ytc.withAudioFilter(["aphaser=in_gain=0.4"]);
                            metaName = `yt-core-(AudioLowest_phaser)-${title}.${outputFormat}`;
                            break;
                        case "reverse":
                            ytc.withAudioFilter(["areverse"]);
                            metaName = `yt-core-(AudioLowest_reverse)-${title}.${outputFormat}`;
                            break;
                        case "slow":
                            ytc.withAudioFilter(["atempo=0.8"]);
                            metaName = `yt-core-(AudioLowest_slow)-${title}.${outputFormat}`;
                            break;
                        case "speed":
                            ytc.withAudioFilter(["atempo=2"]);
                            metaName = `yt-core-(AudioLowest_speed)-${title}.${outputFormat}`;
                            break;
                        case "subboost":
                            ytc.withAudioFilter(["asubboost"]);
                            metaName = `yt-core-(AudioLowest_subboost)-${title}.${outputFormat}`;
                            break;
                        case "superslow":
                            ytc.withAudioFilter(["atempo=0.5"]);
                            metaName = `yt-core-(AudioLowest_superslow)-${title}.${outputFormat}`;
                            break;
                        case "superspeed":
                            ytc.withAudioFilter(["atempo=3"]);
                            metaName = `yt-core-(AudioLowest_superspeed)-${title}.${outputFormat}`;
                            break;
                        case "surround":
                            ytc.withAudioFilter(["surround"]);
                            metaName = `yt-core-(AudioLowest_surround)-${title}.${outputFormat}`;
                            break;
                        case "vaporwave":
                            ytc.withAudioFilter(["aresample=48000,asetrate=48000*0.8"]);
                            metaName = `yt-core-(AudioLowest_vaporwave)-${title}.${outputFormat}`;
                            break;
                        case "vibrato":
                            ytc.withAudioFilter(["vibrato=f=6.5"]);
                            metaName = `yt-core-(AudioLowest_vibrato)-${title}.${outputFormat}`;
                            break;
                        default:
                            ytc.withAudioFilter([]);
                            metaName = `yt-core-(AudioLowest)-${title}.${outputFormat}`;
                            break;
                    }
                    if (stream) {
                        const readStream = new Readable({
                            read() { },
                        });
                        const writeStream = new Writable({
                            write(chunk, _encoding, callback) {
                                readStream.push(chunk);
                                callback();
                            },
                            final(callback) {
                                readStream.push(null);
                                callback();
                            },
                        });
                        ytc.pipe(writeStream, { end: true });
                        results.push({
                            stream: readStream,
                            filename: folderName ? path.join(metaFold, metaName) : metaName,
                        });
                    }
                    else {
                        await new Promise((resolve, reject) => {
                            ytc
                                .output(path.join(metaFold, metaName))
                                .on("end", () => resolve())
                                .on("error", reject)
                                .run();
                        });
                    }
                }
                catch (error) {
                    results.push({
                        status: 500,
                        message: colors.bold.red("ERROR: ") + video.title,
                    });
                }
            });
            return results;
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return [
                    {
                        message: error.message,
                        status: 500,
                    },
                ];
            default:
                return [
                    {
                        message: "Internal server error",
                        status: 500,
                    },
                ];
        }
    }
}

async function ListAudioHighest({ filter, stream, verbose, folderName, playlistUrls, outputFormat = "mp3", }) {
    try {
        if (!Array.isArray(playlistUrls) ||
            !playlistUrls.every((url) => typeof url === "string")) {
            return [
                {
                    message: "Invalid playlistUrls[] parameter. Expecting an array of strings.",
                    status: 500,
                },
            ];
        }
        const videos = await get_playlist({
            playlistUrls,
        });
        if (!videos) {
            return [
                {
                    message: "Unable to get response from YouTube...",
                    status: 500,
                },
            ];
        }
        else {
            const results = [];
            await async.eachSeries(videos, async (video) => {
                try {
                    const metaBody = await Engine({ query: video.url });
                    if (!metaBody) {
                        throw new Error("Unable to get response from YouTube...");
                    }
                    let metaName = "";
                    const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
                    const metaFold = folderName
                        ? path.join(process.cwd(), folderName)
                        : process.cwd();
                    if (!fs.existsSync(metaFold))
                        fs.mkdirSync(metaFold, { recursive: true });
                    const metaEntry = bigEntry(metaBody.AudioTube);
                    const ytc = fluentffmpeg();
                    ytc.input(metaEntry.meta_dl.mediaurl);
                    ytc.input(metaBody.metaTube.thumbnail);
                    ytc.addOutputOption("-map", "1:0");
                    ytc.addOutputOption("-map", "0:a:0");
                    ytc.addOutputOption("-id3v2_version", "3");
                    ytc.format(outputFormat);
                    ytc.on("start", (cmd) => {
                        if (verbose)
                            console.log(cmd);
                        progressBar(0);
                    });
                    ytc.on("end", () => progressBar(100));
                    ytc.on("close", () => progressBar(100));
                    ytc.on("progress", ({ percent }) => progressBar(percent));
                    switch (filter) {
                        case "bassboost":
                            ytc.withAudioFilter(["bass=g=10,dynaudnorm=f=150"]);
                            metaName = `yt-core-(AudioHighest_bassboost)-${title}.${outputFormat}`;
                            break;
                        case "echo":
                            ytc.withAudioFilter(["aecho=0.8:0.9:1000:0.3"]);
                            metaName = `yt-core-(AudioHighest_echo)-${title}.${outputFormat}`;
                            break;
                        case "flanger":
                            ytc.withAudioFilter(["flanger"]);
                            metaName = `yt-core-(AudioHighest_flanger)-${title}.${outputFormat}`;
                            break;
                        case "nightcore":
                            ytc.withAudioFilter(["aresample=48000,asetrate=48000*1.25"]);
                            metaName = `yt-core-(AudioHighest_nightcore)-${title}.${outputFormat}`;
                            break;
                        case "panning":
                            ytc.withAudioFilter(["apulsator=hz=0.08"]);
                            metaName = `yt-core-(AudioHighest_panning)-${title}.${outputFormat}`;
                            break;
                        case "phaser":
                            ytc.withAudioFilter(["aphaser=in_gain=0.4"]);
                            metaName = `yt-core-(AudioHighest_phaser)-${title}.${outputFormat}`;
                            break;
                        case "reverse":
                            ytc.withAudioFilter(["areverse"]);
                            metaName = `yt-core-(AudioHighest_reverse)-${title}.${outputFormat}`;
                            break;
                        case "slow":
                            ytc.withAudioFilter(["atempo=0.8"]);
                            metaName = `yt-core-(AudioHighest_slow)-${title}.${outputFormat}`;
                            break;
                        case "speed":
                            ytc.withAudioFilter(["atempo=2"]);
                            metaName = `yt-core-(AudioHighest_speed)-${title}.${outputFormat}`;
                            break;
                        case "subboost":
                            ytc.withAudioFilter(["asubboost"]);
                            metaName = `yt-core-(AudioHighest_subboost)-${title}.${outputFormat}`;
                            break;
                        case "superslow":
                            ytc.withAudioFilter(["atempo=0.5"]);
                            metaName = `yt-core-(AudioHighest_superslow)-${title}.${outputFormat}`;
                            break;
                        case "superspeed":
                            ytc.withAudioFilter(["atempo=3"]);
                            metaName = `yt-core-(AudioHighest_superspeed)-${title}.${outputFormat}`;
                            break;
                        case "surround":
                            ytc.withAudioFilter(["surround"]);
                            metaName = `yt-core-(AudioHighest_surround)-${title}.${outputFormat}`;
                            break;
                        case "vaporwave":
                            ytc.withAudioFilter(["aresample=48000,asetrate=48000*0.8"]);
                            metaName = `yt-core-(AudioHighest_vaporwave)-${title}.${outputFormat}`;
                            break;
                        case "vibrato":
                            ytc.withAudioFilter(["vibrato=f=6.5"]);
                            metaName = `yt-core-(AudioHighest_vibrato)-${title}.${outputFormat}`;
                            break;
                        default:
                            ytc.withAudioFilter([]);
                            metaName = `yt-core-(AudioHighest)-${title}.${outputFormat}`;
                            break;
                    }
                    if (stream) {
                        const readStream = new Readable({
                            read() { },
                        });
                        const writeStream = new Writable({
                            write(chunk, _encoding, callback) {
                                readStream.push(chunk);
                                callback();
                            },
                            final(callback) {
                                readStream.push(null);
                                callback();
                            },
                        });
                        ytc.pipe(writeStream, { end: true });
                        results.push({
                            stream: readStream,
                            filename: folderName ? path.join(metaFold, metaName) : metaName,
                        });
                    }
                    else {
                        await new Promise((resolve, reject) => {
                            ytc
                                .output(path.join(metaFold, metaName))
                                .on("end", () => resolve())
                                .on("error", reject)
                                .run();
                        });
                    }
                }
                catch (error) {
                    results.push({
                        status: 500,
                        message: colors.bold.red("ERROR: ") + video.title,
                    });
                }
            });
            return results;
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return [
                    {
                        message: error.message,
                        status: 500,
                    },
                ];
            default:
                return [
                    {
                        message: "Internal server error",
                        status: 500,
                    },
                ];
        }
    }
}

async function ListAudioQualityCustom({ filter, stream, quality, verbose, folderName, playlistUrls, outputFormat = "mp3", }) {
    try {
        if (!Array.isArray(playlistUrls) ||
            !playlistUrls.every((url) => typeof url === "string")) {
            return [
                {
                    message: "Invalid playlistUrls[] parameter. Expecting an array of strings.",
                    status: 500,
                },
            ];
        }
        const videos = await get_playlist({
            playlistUrls,
        });
        if (!videos) {
            return [
                {
                    message: "Unable to get response from YouTube...",
                    status: 500,
                },
            ];
        }
        else {
            const results = [];
            await async.eachSeries(videos, async (video) => {
                try {
                    let metaBody;
                    metaBody = await Engine({ query: video.url });
                    if (!metaBody) {
                        results.push({
                            message: "Unable to get response from YouTube...",
                            status: 500,
                        });
                    }
                    else {
                        metaBody = metaBody.AudioTube.filter((op) => op.meta_dl.formatnote === quality);
                        if (!metaBody) {
                            results.push({
                                message: "Unable to get response from YouTube...",
                                status: 500,
                            });
                        }
                        else {
                            let metaName = "";
                            const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
                            const metaFold = folderName
                                ? path.join(process.cwd(), folderName)
                                : process.cwd();
                            if (!fs.existsSync(metaFold))
                                fs.mkdirSync(metaFold, { recursive: true });
                            const metaEntry = bigEntry(metaBody.AudioTube);
                            const ytc = fluentffmpeg();
                            ytc.input(metaEntry.meta_dl.mediaurl);
                            ytc.input(metaBody.metaTube.thumbnail);
                            ytc.addOutputOption("-map", "1:0");
                            ytc.addOutputOption("-map", "0:a:0");
                            ytc.addOutputOption("-id3v2_version", "3");
                            ytc.format(outputFormat);
                            ytc.on("start", (cmd) => {
                                if (verbose)
                                    console.log(cmd);
                                progressBar(0);
                            });
                            ytc.on("end", () => progressBar(100));
                            ytc.on("close", () => progressBar(100));
                            ytc.on("progress", ({ percent }) => progressBar(percent));
                            switch (filter) {
                                case "bassboost":
                                    ytc.withAudioFilter(["bass=g=10,dynaudnorm=f=150"]);
                                    metaName = `yt-core-(AudioQualityCustom_bassboost)-${title}.${outputFormat}`;
                                    break;
                                case "echo":
                                    ytc.withAudioFilter(["aecho=0.8:0.9:1000:0.3"]);
                                    metaName = `yt-core-(AudioQualityCustom_echo)-${title}.${outputFormat}`;
                                    break;
                                case "flanger":
                                    ytc.withAudioFilter(["flanger"]);
                                    metaName = `yt-core-(AudioQualityCustom_flanger)-${title}.${outputFormat}`;
                                    break;
                                case "nightcore":
                                    ytc.withAudioFilter([
                                        "aresample=48000,asetrate=48000*1.25",
                                    ]);
                                    metaName = `yt-core-(AudioQualityCustom_nightcore)-${title}.${outputFormat}`;
                                    break;
                                case "panning":
                                    ytc.withAudioFilter(["apulsator=hz=0.08"]);
                                    metaName = `yt-core-(AudioQualityCustom_panning)-${title}.${outputFormat}`;
                                    break;
                                case "phaser":
                                    ytc.withAudioFilter(["aphaser=in_gain=0.4"]);
                                    metaName = `yt-core-(AudioQualityCustom_phaser)-${title}.${outputFormat}`;
                                    break;
                                case "reverse":
                                    ytc.withAudioFilter(["areverse"]);
                                    metaName = `yt-core-(AudioQualityCustom_reverse)-${title}.${outputFormat}`;
                                    break;
                                case "slow":
                                    ytc.withAudioFilter(["atempo=0.8"]);
                                    metaName = `yt-core-(AudioQualityCustom_slow)-${title}.${outputFormat}`;
                                    break;
                                case "speed":
                                    ytc.withAudioFilter(["atempo=2"]);
                                    metaName = `yt-core-(AudioQualityCustom_speed)-${title}.${outputFormat}`;
                                    break;
                                case "subboost":
                                    ytc.withAudioFilter(["asubboost"]);
                                    metaName = `yt-core-(AudioQualityCustom_subboost)-${title}.${outputFormat}`;
                                    break;
                                case "superslow":
                                    ytc.withAudioFilter(["atempo=0.5"]);
                                    metaName = `yt-core-(AudioQualityCustom_superslow)-${title}.${outputFormat}`;
                                    break;
                                case "superspeed":
                                    ytc.withAudioFilter(["atempo=3"]);
                                    metaName = `yt-core-(AudioQualityCustom_superspeed)-${title}.${outputFormat}`;
                                    break;
                                case "surround":
                                    ytc.withAudioFilter(["surround"]);
                                    metaName = `yt-core-(AudioQualityCustom_surround)-${title}.${outputFormat}`;
                                    break;
                                case "vaporwave":
                                    ytc.withAudioFilter(["aresample=48000,asetrate=48000*0.8"]);
                                    metaName = `yt-core-(AudioQualityCustom_vaporwave)-${title}.${outputFormat}`;
                                    break;
                                case "vibrato":
                                    ytc.withAudioFilter(["vibrato=f=6.5"]);
                                    metaName = `yt-core-(AudioQualityCustom_vibrato)-${title}.${outputFormat}`;
                                    break;
                                default:
                                    ytc.withAudioFilter([]);
                                    metaName = `yt-core-(AudioQualityCustom)-${title}.${outputFormat}`;
                                    break;
                            }
                            if (stream) {
                                const readStream = new Readable({
                                    read() { },
                                });
                                const writeStream = new Writable({
                                    write(chunk, _encoding, callback) {
                                        readStream.push(chunk);
                                        callback();
                                    },
                                    final(callback) {
                                        readStream.push(null);
                                        callback();
                                    },
                                });
                                ytc.pipe(writeStream, { end: true });
                                results.push({
                                    stream: readStream,
                                    filename: folderName
                                        ? path.join(metaFold, metaName)
                                        : metaName,
                                });
                            }
                            else {
                                await new Promise((resolve, reject) => {
                                    ytc
                                        .output(path.join(metaFold, metaName))
                                        .on("end", () => resolve())
                                        .on("error", reject)
                                        .run();
                                });
                            }
                        }
                    }
                }
                catch (error) {
                    results.push({
                        status: 500,
                        message: colors.bold.red("ERROR: ") + video.title,
                    });
                }
            });
            return results;
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return [
                    {
                        message: error.message,
                        status: 500,
                    },
                ];
            default:
                return [
                    {
                        message: "Internal server error",
                        status: 500,
                    },
                ];
        }
    }
}

async function ListAudioVideoLowest({ stream, verbose, folderName, playlistUrls, outputFormat = "mp4", }) {
    try {
        if (!Array.isArray(playlistUrls) ||
            !playlistUrls.every((url) => typeof url === "string")) {
            return [
                {
                    message: "Invalid playlistUrls[] parameter. Expecting an array of strings.",
                    status: 500,
                },
            ];
        }
        const videos = await get_playlist({
            playlistUrls,
        });
        if (!videos) {
            return [
                {
                    message: "Unable to get response from YouTube...",
                    status: 500,
                },
            ];
        }
        else {
            const results = [];
            await async.eachSeries(videos, async (video) => {
                try {
                    const metaBody = await Engine({ query: video.url });
                    if (!metaBody) {
                        throw new Error("Unable to get response from YouTube...");
                    }
                    const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
                    let metaName = `yt-core_(AudioVideoLowest)_${title}.${outputFormat}`;
                    const metaFold = folderName
                        ? path.join(process.cwd(), folderName)
                        : process.cwd();
                    if (!fs.existsSync(metaFold))
                        fs.mkdirSync(metaFold, { recursive: true });
                    const ytc = fluentffmpeg();
                    ytc.input(lowEntry(metaBody.VideoTube).meta_dl.mediaurl);
                    ytc.input(lowEntry(metaBody.AudioTube).meta_dl.mediaurl);
                    ytc.format(outputFormat); // Set the output format
                    ytc.on("start", (cmd) => {
                        if (verbose)
                            console.log(cmd);
                        progressBar(0);
                    });
                    ytc.on("end", () => progressBar(100));
                    ytc.on("close", () => progressBar(100));
                    ytc.on("progress", ({ percent }) => progressBar(percent));
                    if (stream) {
                        const readStream = new Readable({
                            read() { },
                        });
                        const writeStream = new Writable({
                            write(chunk, _encoding, callback) {
                                readStream.push(chunk);
                                callback();
                            },
                            final(callback) {
                                readStream.push(null);
                                callback();
                            },
                        });
                        ytc.pipe(writeStream, { end: true });
                        results.push({
                            stream: readStream,
                            filename: folderName ? path.join(metaFold, metaName) : metaName,
                        });
                    }
                    else {
                        await new Promise((resolve, reject) => {
                            ytc
                                .output(path.join(metaFold, metaName))
                                .on("end", () => resolve())
                                .on("error", reject)
                                .run();
                        });
                    }
                }
                catch (error) {
                    results.push({
                        status: 500,
                        message: colors.bold.red("ERROR: ") + video.title,
                    });
                }
            });
            return results;
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return [
                    {
                        message: error.message,
                        status: 500,
                    },
                ];
            default:
                return [
                    {
                        message: "Internal server error",
                        status: 500,
                    },
                ];
        }
    }
}

async function ListAudioVideoHighest({ stream, verbose, folderName, playlistUrls, outputFormat = "mp4", }) {
    try {
        if (!Array.isArray(playlistUrls) ||
            !playlistUrls.every((url) => typeof url === "string")) {
            return [
                {
                    message: "Invalid playlistUrls[] parameter. Expecting an array of strings.",
                    status: 500,
                },
            ];
        }
        const videos = await get_playlist({
            playlistUrls,
        });
        if (!videos) {
            return [
                {
                    message: "Unable to get response from YouTube...",
                    status: 500,
                },
            ];
        }
        else {
            const results = [];
            await async.eachSeries(videos, async (video) => {
                try {
                    const metaBody = await Engine({ query: video.url });
                    if (!metaBody) {
                        throw new Error("Unable to get response from YouTube...");
                    }
                    const title = metaBody.metaTube.title.replace(/[^a-zA-Z0-9_]+/g, "-");
                    let metaName = `yt-core_(AudioVideoHighest)_${title}.${outputFormat}`;
                    const metaFold = folderName
                        ? path.join(process.cwd(), folderName)
                        : process.cwd();
                    if (!fs.existsSync(metaFold))
                        fs.mkdirSync(metaFold, { recursive: true });
                    const ytc = fluentffmpeg();
                    ytc.input(bigEntry(metaBody.VideoTube).meta_dl.mediaurl);
                    ytc.input(bigEntry(metaBody.AudioTube).meta_dl.mediaurl);
                    ytc.format(outputFormat); // Set the output format
                    ytc.on("start", (cmd) => {
                        if (verbose)
                            console.log(cmd);
                        progressBar(0);
                    });
                    ytc.on("end", () => progressBar(100));
                    ytc.on("close", () => progressBar(100));
                    ytc.on("progress", ({ percent }) => progressBar(percent));
                    if (stream) {
                        const readStream = new Readable({
                            read() { },
                        });
                        const writeStream = new Writable({
                            write(chunk, _encoding, callback) {
                                readStream.push(chunk);
                                callback();
                            },
                            final(callback) {
                                readStream.push(null);
                                callback();
                            },
                        });
                        ytc.pipe(writeStream, { end: true });
                        results.push({
                            stream: readStream,
                            filename: folderName ? path.join(metaFold, metaName) : metaName,
                        });
                    }
                    else {
                        await new Promise((resolve, reject) => {
                            ytc
                                .output(path.join(metaFold, metaName))
                                .on("end", () => resolve())
                                .on("error", reject)
                                .run();
                        });
                    }
                }
                catch (error) {
                    results.push({
                        status: 500,
                        message: colors.bold.red("ERROR: ") + video.title,
                    });
                }
            });
            return results;
        }
    }
    catch (error) {
        switch (true) {
            case error instanceof Error:
                return [
                    {
                        message: error.message,
                        status: 500,
                    },
                ];
            default:
                return [
                    {
                        message: "Internal server error",
                        status: 500,
                    },
                ];
        }
    }
}

const ytCore = {
    info: {
        help,
        extract,
        search,
        list_formats,
        get_playlist,
        get_video_data,
        extract_playlist_videos,
    },
    audio: {
        single: {
            lowest: AudioLowest,
            highest: AudioHighest,
            custom: AudioQualityCustom,
        },
        playlist: {
            lowest: ListAudioLowest,
            highest: ListAudioHighest,
            custom: ListAudioQualityCustom,
        },
    },
    video: {
        single: {
            lowest: VideoLowest,
            highest: VideoHighest,
            custom: VideoQualityCustom,
        },
        playlist: {
            lowest: ListVideoLowest,
            highest: ListVideoHighest,
            custom: ListVideoQualityCustom,
        },
    },
    audio_video: {
        single: {
            lowest: AudioVideoLowest,
            highest: AudioVideoHighest,
        },
        playlist: { lowest: ListAudioVideoLowest, highest: ListAudioVideoHighest },
    },
};

export { ytCore as default };
/**
 * ============================================[ ğŸ“¢YOUTUBE DOWNLOADER CORE <( YT-CORE )/>ğŸ“¹ ]====================================
 * ğŸš€ Unlock effortless audio/video downloads with YT-COREâ€”a command-line, Node.js, and streaming powerhouse.
 * ğŸµ Meticulously designed for enthusiasts, YT-CORE stands out as a feature-rich package, evolving with state-of-the-art
 * ğŸ”¥ functionalities from Youtube-DL and Python yt-core.
 * ğŸš€ Elevate your media experience!
 * ğŸŒˆ Dive into the world of limitless possibilities.
 * ============================================[ ğŸš¨License: MIT] [ ğŸ§™ğŸ»Owner: ShovitDutta]====================================
 * MIT License
 * Original Library
 * - Copyright (c) Shovit Dutta <shovitdutta1@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * ============================================[ ğŸš¨License: MIT] [ ğŸ§™ğŸ»Owner: ShovitDutta]====================================
 */
